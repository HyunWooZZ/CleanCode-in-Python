### 생성 패턴
1. 팩토리 패턴
복작한 설정 또는 반복적으로 객체를 초기화하지 않으면서 의존성 주입의 경우 pyinject를 사용하거나 직접 비슷한 구조를 개발해야함.

2. 싱글턴 패턴
파이썬에 의해 완전히 추상화되지 않은 패턴 => 단위 테스트가 어려움
따라서 여러 인스턴스를 동일한 상태로 만드는 것이 더 좋음!!! (monostate)
디스크립터를 활용하거나, 클래스 변수를 활용하거나 borg 패턴을 활용하면 됨.


### 구조 패턴
구조 패턴은 인터페이스를 복잡하게 하지 않으면서도 기능을 확장하여 더 강력한 인터페이스 또는 객체를 만들어야 하는 상황에서 유용

1. 어댑터 패턴

1.1 기존 클래스를 상속받은 새로운 클래스를 만드는 것!!
상속받은 클래스는 호환이 필요한 메서드를 래핑하는 새로운 별칭의 메소드를 만듬!! 이 메소드 내부에서는 기존 코드에 적응하여, 자신의 호출 결과가 기존 코드와 호환이 되도록 맞추어 결과를 반환해야함. but 상속을 하면 결합도가 높아져 유연성이 떨어지게됨.

1.2 컴포지션 활용
단일 객체와 복합 객체를 동일하게 사용할 수 있도록 구현하는 것!!

1.3 데코레이터
객체의 기능을 동적으로 확장 가능!! 

1.4 파사드
객체간 상호 작용을 단순화하려는 상황에서 유용. 파사드는 허브 또는 단일 참조점의 역할을 함.
객체의 결합력을 낮추고, 인터베이스의 개수를 줄이고, 보다 나은 캡슐화를 지원하는 역할을 하며 또한 더 나은 코드의 엔트리 포인트 역할을 하여 사용자가 필요한 부분 또는 노출된 기능만 쉽게 사용할 수 있음.

### 행동 패턴

1. 책임 연쇄 패턴
 객체가 어떤 작업을 처리하는데 이 작업을 처리할 수 있는 여러 객체 중 하나를 선택하는 방법을 제공합니다. 이 패턴은 요청이 한 객체에서 다른 객체로 자동으로 전달되어 처리될 때 유용하게 쓰입니다.
책임 연쇄 패턴의 핵심 아이디어는 요청을 처리할 수 있는 여러 객체(책임 체인)를 연결하고, 요청이 한 객체에서 다른 객체로 전달되며, 어떤 객체가 실제로 요청을 처리할지 결정됩니다. 요청을 처리할 수 있는 객체를 찾을 때까지 연결된 객체를 순차적으로 탐색합니다. 이로써 요청 처리를 담당하는 객체들 간에 결합도를 낮추고, 유연성을 높일 수 있습니다.

파이썬에서 책임 연쇄 패턴을 구현하기 위해 보통 다음과 같은 구성 요소를 사용합니다:

Handler 인터페이스 또는 추상 클래스: 이 인터페이스나 추상 클래스는 처리 메서드를 선언하고, 구체적인 핸들러 클래스들이 이를 구현하도록 합니다.

구체적인 핸들러 클래스: 이러한 클래스들은 요청을 처리하는 실제 로직을 구현하며, 필요한 경우 다음 핸들러로 요청을 전달합니다.

클라이언트: 요청을 시작하는 객체로, 요청 객체를 생성하고 체인의 첫 번째 핸들러에게 요청을 보냅니다.

책임 연쇄 패턴의 장점은 요청을 처리하는 객체들을 동적으로 변경하거나 추가할 수 있으며, 요청 처리 순서를 자유롭게 조정할 수 있다는 점입니다. 이 패턴은 주로 로깅, 예외 처리, 유효성 검사 및 필터링과 같은 작업에서 사용됩니다.

예를 들어, 다양한 로그 레벨에 대한 로그 메시지를 처리하는 로깅 시스템을 구현할 때 책임 연쇄 패턴을 활용할 수 있습니다. 각 핸들러 클래스는 특정 로그 레벨에 해당하는 로그 메시지를 처리하고, 다음 핸들러로 전달하거나 처리를 중단할 수 있습니다.

2. 탬플릿 메서드 패턴
템플릿 메서드 패턴(Template Method Pattern)은 객체지향 디자인 패턴 중 하나입니다. 이 패턴의 핵심은 알고리즘의 구조를 정의하고, 일부 단계를 서브클래스에서 구현하도록 하는 것입니다. 즉, 알고리즘의 일부 변경 가능한 부분을 서브클래스에서 확장할 수 있도록 함으로써 코드의 재사용성을 높이고, 중복을 줄이는 것이 목적입니다.  => 공통 로직을 최대한 활용하는 것


템플릿 메서드 패턴의 구조는 다음과 같습니다:

추상 클래스 (Abstract Class): 이 클래스에서는 템플릿 메서드를 정의합니다. 템플릿 메서드는 여러 단계로 이루어진 알고리즘의 틀을 제공하며, 이 중 일부 또는 모든 단계가 추상 메서드로 정의될 수 있습니다. 이 추상 메서드들은 서브클래스에서 구현됩니다.

구체 클래스 (Concrete Class): 추상 클래스를 상속받는 구체 클래스에서는 부모 클래스의 추상 메서드를 구현합니다. 이렇게 함으로써 알고리즘의 특정 단계를 커스터마이즈할 수 있습니다.

템플릿 메서드 패턴의 주요 이점은 다음과 같습니다:

코드 재사용성 증가: 공통적인 알고리즘은 한 번만 작성하고, 변화하는 부분만 서브클래스에서 구현함으로써 코드의 중복을 줄일 수 있습니다.
확장성: 새로운 서브클래스를 만들어 기존 알고리즘의 특정 부분만 변경할 수 있으므로, 확장성이 좋습니다.
유지보수 용이: 공통 알고리즘 부분의 변경이 필요한 경우, 추상 클래스만 수정하면 되므로 유지보수가 용이합니다.

템플릿 메서드 패턴 사용시 주의해야 할 점:

너무 많은 일반화: 템플릿 메서드가 너무 많은 것을 처리하려고 하면, 서브클래스에서 구현해야 할 내용이 많아져 복잡해질 수 있습니다.
리스코프 치환 원칙 위반: 서브클래스가 부모 클래스의 기능을 제대로 구현하지 않으면, 리스코프 치환 원칙을 위반할 수 있습니다. 이는 소프트웨어의 일관성과 신뢰성을 해칠 수 있습니다.
유연성의 한계: 템플릿 메서드는 알고리즘의 구조를 고정시키기 때문에, 구조 자체를 변경하고자 할 때는 다른 패턴을 고려하는 것이 좋을 수 있습니다.
이러한 점들을 고려하면서 템플릿 메서드 패턴을 적용한다면, 소프트웨어의 설계를 효율적이고 유지보수가 용이하게 할 수 있습니다.

3. 커맨드 패턴
작업을 요청한 순간부터 실제 실행 시까지 분리할 수 있는 기능을 제공하는 패턴
커맨드도 정의 이후에 수정가능함!! 실행과 커맨드 만드는 것은 별개이기 때문



